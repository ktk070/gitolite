#!/usr/bin/perl

use strict;
use warnings;

# === auth-command ===
# the command that GL users actually run

# part of the gitolite (GL) suite

# how run:      via sshd, being listed in "command=" in ssh authkeys
# when:         every login by a GL user
# input:        $1 is GL username, plus $SSH_ORIGINAL_COMMAND
# output:
# security:
#     - currently, we just make some basic checks, copied from gitosis

# robustness:

# other notes:

# ----------------------------------------------------------------------------
#       common definitions
# ----------------------------------------------------------------------------


our ($GL_LOGT, $GL_CONF_COMPILED, $REPO_BASE);
our %repos;

my $glrc = $ENV{HOME} . "/.gitolite.rc";
die "parse $glrc failed: "             . ($! or $@) unless do $glrc;
die "parse $GL_CONF_COMPILED failed: " . ($! or $@) unless do $GL_CONF_COMPILED;

# ----------------------------------------------------------------------------
#       definitions specific to this program
# ----------------------------------------------------------------------------

my $R_COMMANDS=qr/^(git[ -]upload-pack|git[ -]upload-archive)$/;
my $W_COMMANDS=qr/^git[ -]receive-pack$/;
my $REPONAME_PATT=qr(^[0-9a-zA-Z][0-9a-zA-Z._/-]*$); # very simple pattern

# ----------------------------------------------------------------------------
#       start...
# ----------------------------------------------------------------------------

# first, fix the biggest gripe I have with gitosis, a 1-line change
my $user=$ENV{GL_USER}=shift;       # there; now that's available everywhere!

# ----------------------------------------------------------------------------
#       sanity checks on SSH_ORIGINAL_COMMAND
# ----------------------------------------------------------------------------

# SSH_ORIGINAL_COMMAND must exist.  Since we also captured $user, we print
# that in the message so people saying "ssh git@server" can see which gitosis
# user he is being recognised as
my $cmd = $ENV{SSH_ORIGINAL_COMMAND}
    or die "no SSH_ORIGINAL_COMMAND?  I'm not a shell, $user!\n";

# this check is largely for comic value if someone tries something outrageous;
# $cmd gets split and the pieces examined more thoroughly later anyway
die "$cmd???  you're a funny guy...\n"
    if $cmd =~ /[<>&|;\n]/;

# split into command and arguments; the pattern allows old style as well as
# new style: "git-subcommand arg" or "git subcommand arg", just like gitosis
# does, although I'm not sure how necessary that is
#
# keep in mind this is how git sends across the command:
#   git-receive-pack 'reponame.git'
# including the single quotes

my ($verb, $repo) = ($cmd =~ /^\s*(git\s+\S+|\S+)\s+'\/?(.*).git'/);
die "Sorry, I don't like the command you gave me: $cmd\n"
    unless ( ( $verb =~ $R_COMMANDS or $verb =~ $W_COMMANDS )
        and  $repo =~ $REPONAME_PATT );

# ----------------------------------------------------------------------------
#       first level permissions check
# ----------------------------------------------------------------------------

# we know the user and repo; we just need to know what perm he's trying
my $perm = ($verb =~ $R_COMMANDS ? 'R' : 'W');

# watch out for wildrepos!  $ENV{GL_REPO_KEY} will store the key under which
# the matching permissions were found in the %repos hash, wild or not
if ($repos{$repo}) {
    # this is the old, pre-wild case, finding $repo itself as a key of %repos
    $ENV{GL_REPO_KEY} = $repo;
} else {
    # treat each key of %repos as a regex and match $repo against it
    my @matched = grep { $repo =~ /$_/ } sort keys %repos;
    die "couldn't find a match for $repo in config file" unless @matched;
    die "too many matches for $repo: " . join(",", @matched) . "\n" if @matched > 1;
    $ENV{GL_REPO_KEY} = $matched[0];
}
die "$perm access for $repo denied to $user\n"
    unless $repos{$ENV{GL_REPO_KEY}}{$perm}{$user}
        or $repos{$ENV{GL_REPO_KEY}}{$perm}{'@all'};

# ----------------------------------------------------------------------------
#       logging, timestamp.  also setup env vars for later
# ----------------------------------------------------------------------------

# reponame
$ENV{GL_REPO}=$repo;

# timestamp
my ($s, $min, $h, $d, $m, $y) = (localtime)[0..5];
$y += 1900; $m++;               # usual adjustments
for ($s, $min, $h, $d, $m) {
    $_ = "0$_" if $_ < 10;
}
$ENV{GL_TS} = "$y-$m-$d.$h:$min:$s";

# substitute template parameters and set the logfile name 
$GL_LOGT =~ s/%y/$y/g;
$GL_LOGT =~ s/%m/$m/g;
$GL_LOGT =~ s/%d/$d/g;
$ENV{GL_LOG} = $GL_LOGT;

# if log failure isn't important enough to block access, get rid of all the
# error checking
open my $log_fh, ">>", $ENV{GL_LOG}
    or die "open log failed: $!\n";
print $log_fh "$ENV{GL_TS}\t$ENV{SSH_ORIGINAL_COMMAND}\t$user\n";
close $log_fh or die "close log failed: $!\n";

# ----------------------------------------------------------------------------
#       over to git now
# ----------------------------------------------------------------------------

$repo = "'$REPO_BASE/$repo.git'";
exec("git", "shell", "-c", "$verb $repo");
